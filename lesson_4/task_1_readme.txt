Я взял задачу по поиску числа с максимальным количеством вхождений в список (4я задача 3го урока).
При использовании функции Counter из модуля collections сложность должна быть O(n), т.к. метод most_common()
класса Counter просто итерируется по списку и считает количество вхождений каждого элемента, однако при малом значении
N время выполнения растет совсем незначительно, ну и надо упомянуть конечно, что встроенные функции работают гораздо
быстрее пользовательских. Также не очень понял, почему при значении N = 1000000 в cProfile всплывают рекурсивные
функции.

При использовании функции find_most_common_dict, которую я использовал в предыдущем дз, сложность алгоритма
уверенно напоминает O(n), потому что время выполнения алгоритма напрямую зависит от количества элементов массива,
что также доказывают замеры с помощью timeit.

При вызове же функции find_most_common_double() я принял совершенно бессмысленное решение использовать
вложенную итерацию по цифрам элементов массива, и хотя замеры timeit напоминают O(n), сложность также вносит
вложенный цикл, с которым сложность алгоритма должна напоминать O(n2), однако замеры показывают обратное.
Если честно, затрудняюсь ответить, какая это сложность алгоритма, но определенно он работает гораздо медленнее,
чем его конкуренты.